!-*-Fortran-*-
!
subroutine fourier_transform(idir, ffts, gs, gsdat, rspace, nfn)
  !
  !
m4_ifdef([SHMEM],[
  !     switched on shmem for second transpose of inv fft m4_define([SHMEM2])])
m4_ifdef([SHMEM],[
  !     switched on shmem for second transpose of fwd fft m4_define([SHMEM3])])
m4_ifdef([T3E],[
  !       need interface blocks  m4_define([INTERFACE])])
m4_ifdef([HODGKIN],[
  !       need interface blocks  m4_define([INTERFACE])])
m4_ifdef([SGI_PC],[
  !       need interface blocks  m4_define([INTERFACE])])
  !
  include 'use.h' 
  implicit none             ! implicit? Just say no!
m4_ifdef([MPI],[include 'mpif.h'])
  include 'interface.h'
m4_ifdef([TIMING],[include 'timing.h'])
  !
  !     INPUT:
  !     -----
  !
  integer, intent(in) :: idir                      ! if >=0  rspace ==> gspace
                                                   ! if <0   rspace <== gspace
  integer, intent(in) :: nfn                      ! number of functions to FFT
  type(fft_struc), intent(in) :: ffts                ! work arrays for the FFT
  type(parallel_gspace), intent(in) :: &
       gs                            ! the gspace for which the data is set up
  !
  !     INPUT/OUTPUT:
  !     ------------
  !
  !     WARNING: UPON TRANSFORM REALSPACE => GSPACE, THE REALSPACE
  !     ARRAY IS DESTROYED.
  !
  complex(dp), intent(inout) :: &
       rspace(gs%r_size * nfn)     ! the data in realspace rspace(ffts%r_size)
  complex(dp), intent(inout) :: &
       gsdat(gs%length * nfn)            ! the data in gspace gsdat(gs%length)
  !
  !     --------------------------------------------------------------------
  !     summer 1996 by Bernd Pfrommer while at UC Berkeley
  !
  !     
  !     DESCRIPTION:
  !     -----------
  !
  !     Takes an array gsdat in fourier space, and transforms it to
  !     realspace, or the other way round. This is done in parallel
  !     using the MPI message passing  library.
  !
  !
  !     Returns in rspace a bunch of rods along the x direction which
  !     belong to this processor. The data layout is as follows:
  !
  !
  !           ------------ Nz
  !           |          |
  !           |          |        
  !           |          |
  !           |   2222222|
  !           |2211111111|
  !           |1000000000|
  !           ------------
  !           Ny
  !
  !
  !     All the information about which processor receives what from
  !     where is contained in the packinfo array, which is attached to
  !     the gspace structure.
  !
  !
  FFT_HEADER
  !
  real(dp) :: t0, ttot, normfac
  integer :: ix, iy,iz, icx, icy, icz, i
  real(dp), external :: gimmetime

m4_ifdef([INTERFACE],[
  interface
     subroutine fourier_transform_12(idir, ffts, gs, gsdat, rspace, nfn)
       include 'use.h'
       integer :: idir, nfn
       type(fft_struc) :: ffts
       type(parallel_gspace) :: gs
       complex(dp), target :: rspace(gs%r_size * nfn)
       complex(dp) :: gsdat(gs%length * nfn)
     end subroutine fourier_transform_12
  end interface
])

m4_ifdef([TIMING],[
  tunfold = dzero ; txfft = dzero ; tyfft = dzero ; tzfft = dzero
  t0rspace = dzero ; ttrods = dzero ; t0t1buf = dzero ; tlt1 = dzero
  tt1 = dzero ; tlt2 = dzero ; tt2 = dzero
])

  if (idir >= 0) then        ! rspace ->gspace
     !
     !        do the first stage of the 3d FFT
     !
     TIMEGET(t0)
     call fourier_transform_3(idir, ffts, gs, rspace(1), nfn)
     !
     !        do the last two stages of the 3d FFT
     !
     call fourier_transform_12(idir, ffts, gs, gsdat(1), rspace(1), nfn)

m4_ifdef([TIMING],[
     TIMEDIFF(ttot,t0)
     write(9,123) txfft, tyfft, tzfft, tunfold, ttrods, &
          t0t1buf, t0rspace, tlt1, tlt2, tt1, tt2
     if (ttot > 1.0d-8) then
        ttot = 1.0d2 / ttot
        write(9,124) txfft * ttot, tyfft * ttot, tzfft * ttot, &
             tunfold * ttot, ttrods * ttot, t0t1buf * ttot, &
             t0rspace * ttot, tlt1 * ttot, tlt2 * ttot, &
             tt1 * ttot, tt2 * ttot
     end if
])
  else                      ! gspace -> rspace
     !
     !        do the last two stages of the 3d FFT
     !
     TIMEGET(t0)
     call fourier_transform_12(idir, ffts, gs, gsdat(1), rspace(1), nfn)
     !
     !        do the first stage of the 3d FFT
     !
     call fourier_transform_3(idir, ffts, gs, rspace(1), nfn)

m4_ifdef([TIMING],[
     TIMEDIFF(ttot,t0)
     write(9,223) txfft, tyfft, tzfft, tunfold, ttrods, &
          t0t1buf, t0rspace, tlt1, tlt2, tt1, tt2
     if (ttot > 1.0d-8) then
        ttot = 1.0d2 / ttot
        write(9,224) txfft * ttot, tyfft * ttot, tzfft * ttot, &
             tunfold * ttot, ttrods * ttot, t0t1buf * ttot, &
             t0rspace * ttot, tlt1 * ttot, tlt2 * ttot, &
             tt1 * ttot, tt2 * ttot    
     end if
])
  end if

  return

123 format('tFFTI:',3f8.4,', tUFOLD:',f8.4,', tTRODS:',f8.4, &
       ', tZBUF:', f8.4,', tZRSPC:', f8.4,', tTLT1:', f8.4, &
       ', tTLT2:', f8.4,', tTC1:', f8.4,', tTC2:', f8.4)
124 format('%FFTI:',3f8.1,', %UFOLD:',f8.1,', %TRODS:',f8.1, &
       ', %ZBUF:', f8.1,', %ZRS%C:', f8.1,', %TLT1:', f8.1, &
       ', %TLT2:', f8.1,', %TC1:', f8.1,', %TC2:', f8.1)
223 format('tFFTF:',3f8.4,', tUFOLD:',f8.4,', tTRODS:',f8.4, &
       ', tZBUF:', f8.4,', tZRSPC:', f8.4,', tTLT1:', f8.4, &
       ', tTLT2:', f8.4,', tTC1:', f8.4,', tTC2:', f8.4)
224 format('%FFTF:',3f8.1,', %UFOLD:',f8.1,', %TRODS:',f8.1, &
       ', %ZBUF:', f8.1,', %ZRSPC:', f8.1,', %TLT1:', f8.1, &
       ', %TLT2:', f8.1,', %TC1:', f8.1,', %TC2:', f8.1)

end subroutine fourier_transform
!
!     ================================================================
!
subroutine fourier_transform_12(idir, ffts, gs, gsdat, rspace, nfn)
  !
  use all_to_all_module
  include 'use.h'
  implicit none             ! implicit? Just say no!
m4_ifdef([MPI],[include 'mpif.h'])
  include 'interface.h'
  include 'all_to_all.h'
  include 'flibcalls.ph'
m4_ifdef([TIMING],[include 'timing.h'])
  !
  !     INPUT:
  !     -----
  !
  integer, intent(in) :: idir                      ! if >=0  rspace ==> gspace
                                                   ! if <0   rspace <== gspace
  integer, intent(in) :: nfn                      ! number of functions to FFT
  type(fft_struc), intent(inout) :: ffts             ! work arrays for the FFT
  type(parallel_gspace), intent(in) :: &
       gs                            ! the gspace for which the data is set up
  !
  !     INPUT/OUTPUT:
  !     ------------
  !
  complex(dp), intent(inout), target :: &
       rspace(gs%r_size * nfn)     ! the data in realspace rspace(ffts%r_size)
  complex(dp), intent(inout) :: &
       gsdat(gs%length * nfn)            ! the data in gspace gsdat(gs%length)
  !
  !     DESCRIPTION:
  !     -----------
  !
  !     performs the first two stages of a forward or an inverse 3dFFT
  !
  !
  !     ---------------------- local variables -------------------------
  !
  integer :: &
       i, j, k, iord, nrods, b, b2, na, na2, rodrange(2), &
       nx, ny, nz, nxp, ireqr, ireqs, ip, ierr, irod, ipack, iofy, &
       psource, ptarget, packinfo, &
       ldx, ldy, ldz, &     ! leading dimensions in x, y, z
       nnx, nny, nnz, &     ! sizes of the fourier grid
       nrodst1, &           ! number of rods after first transposition
       nrodst2, &           ! number of rods after second transposition
       dnx, &               ! number of nx slabs after t1
       ioffset, &           ! rod offset for myproc on nz/ny grid
       srod, sy, slen, swidth, drod, dx, dlen, ix, ichunk, &
       poffset, dwidth, &   !
       npacksend, &         ! counter for num pack send
       dwx, dwy, dwz, dw2,& ! pointers into the work array
       ifn                  ! labels function
m4_ifdef([MPI],[ 
  integer :: istatus(MPI_STATUS_SIZE)
])
  real(dp) :: t0, t1, t2
  complex(dp) :: dummy

  FFT_HEADER

  real(dp), external :: gimmetime

m4_ifdef([SHMEM],[
  integer :: t1bufsize, ufbufsize, sendbufsize
  complex(dp) :: t1buf(1), ufb(1), sendbuf(1), dumbuf(1) 
  pointer(t1buf_p, t1buf)
  pointer(ufb_p, ufb)
  pointer(dumbuf_p, dumbuf)       
  pointer(sendbuf_p, sendbuf)
  t1bufsize = size(ffts%t1buf) * 2
  call all_max_all(t1bufsize)
  ufbufsize = (ffts%fftsize(3) + 1) * gs%lorder * 2
  call all_max_all(ufbufsize)
  sendbufsize = size(ffts%sendbuf) * 2
  call all_max_all(sendbufsize)

  call shpalloc(t1buf_p, t1bufsize, ierr, -1)
  call shpalloc(ufb_p, ufbufsize, ierr, -1)
  call shpalloc(sendbuf_p, sendbufsize, ierr, -1)
],[
  complex(dp), pointer :: t1buf(:), ufb(:), sendbuf(:)
  t1buf => ffts%t1buf
  ufb => rspace
  sendbuf => ffts%sendbuf
])

  nnx = gs%fftsize(1) ; nny = gs%fftsize(2) ; nnz = gs%fftsize(3)
  dnx = mod(gs%fftsize(4) - gs%fftsize(5) + nnx, nnx) + 1

  nrodst1 = (dnx * nnz) / gs%nproc 
  if (mod(dnx * nnz, gs%nproc) > gs%myproc) nrodst1 = nrodst1 + 1

  nrodst2 = (nny * nnz) / gs%nproc 
  if (mod(nny * nnz, gs%nproc) > gs%myproc) nrodst2 = nrodst2 + 1
  !
  !     variables for local T2 transpose. See setup_packinfo
  !
  b = (dnx * nnz) / gs%nproc ; na = mod(dnx * nnz, gs%nproc)
  b2 = (nny * nnz) / gs%nproc ; na2 = mod(nny * nnz, gs%nproc)
  !
  rodrange(1) = b2 * gs%myproc + min(gs%myproc, na2)
  rodrange(2) = rodrange(1) + b2
  if (na2 <= gs%myproc) rodrange(2) = rodrange(2) - 1
  !
  ioffset = b * gs%myproc + min(gs%myproc, na)
  !
  !     do some sanity checks
  !
  if (ffts%fftsize(1) /= gs%fftsize(1) .or. &
       ffts%fftsize(2) /= gs%fftsize(2) .or. &
       ffts%fftsize(3) /= gs%fftsize(3))then 
     write(9, *) 'fftsize mismatch between gspace:', &
          gs%fftsize(1:3), 'and ffts:', ffts%fftsize
     stop
  end if
  !
  !     figure out leading dimensions for the cray optimization
  !
  ldx = nnx ; ldy = nny ; ldz = nnz
m4_ifdef([VECTOR],[
  if (mod(ldx, 2) == 0) ldx = ldx + 1 
  if (mod(ldy, 2) == 0) ldy = ldy + 1
  if (mod(ldz, 2) == 0) ldz = ldz + 1
])
m4_ifdef([SR2201],[
  if (mod(ldx, 2) == 0) ldx = ldx + 1 
  if (mod(ldy, 2) == 0) ldy = ldy + 1
  if (mod(ldz, 2) == 0) ldz = ldz + 1
])

  if (ldz * gs%lorder > gs%r_size) then
     write(9, *) ' FFT: strange geometry used...'
     write(9, *) ' change code not to abuse rspace as buffer!'
     stop
  end if
  !
  !     compute pointers into the work array 
  !
  dwx = 1 ; dwy = ffts%naux(1) + 1 ; dwz = ffts%naux(1) + ffts%naux(2) + 1
  dw2 = ffts%naux(1) + ffts%naux(2) + ffts%naux(3) + 1

  if (idir < 0) then ! from gspace to realspace
     !
     !     ================   FROM GSPACE TO REALSPACE ===================
     !                        (inverse or backward FFT)
     !
     !        Set the data up for the first fourier transform.
     !        All the rods on this processor are put next to each other
     !        into the unfold buffer, and then fourier transformed with 
     !        a block routine for optimum performance.
     ! 

     ! pdh print out input data (gspace)
     !      do ifn=0,nfn-1
     !      write(*,*) 'WFN:',ifn+1,' of ',nfn
     !      write(*,*) gsdat(1+ifn*gs%length:(ifn+1)*gs%length)
     !      end do

     TIMEGET(t0)
m4_ifdef([SGI_PC],[
     call fftunfoldc(gsdat(1), ufb(1), ldz, gs%order(1,1), gs%lorder, &
          gs%length, nfn)
  ],[
  m4_ifdef([HODGKIN],[
     call fftunfoldc(gsdat(1), ufb(1), ldz, gs%order(1,1), gs%lorder, &
          gs%length, nfn)
  ],[

     call fftunfold(gsdat(1), gs, ufb(1), ldz, nfn)
  ])
])
     TIMEDIFF(tunfold,t0)
     ! pdh print out unfold buffer
     !
     !      do ifn=0,nfn-1
     !      write(*,*) 'WFN:',ifn+1,' of ',nfn
     !      write(*,*) 'ldz=',ldz
     !      write(*,*) 'gs%lorder=',gs%lorder
     !      write(*,*) 'gs%length=',gs%length
     !      write(*,*) ufb(1+ifn*ldz*gs%lorder:ldz*gs%lorder*(ifn+1))
     !      end do

     !
     !     ---- inverse fourier transform in z direction locally ----
     !
     TIMEGET(t0)
m4_ifdef([VECTOR],[
     call ccfftm(0, nnz, gs%lorder * nfn, done, ufb(1), ldz, ufb(1), ldz, &
          ffts%workspace(dwz), ffts%workspace(dw2), 0)
     call ccfftm(-1, nnz, gs%lorder * nfn, done, ufb(1), ldz, ufb(1), ldz, &
          ffts%workspace(dwz), ffts%workspace(dw2), 0)
])

     FFT_AUX_SPACE(ffts%workspace(dwz), ffts%naux(3), ffts%workspace(dw2), ffts%naux(4), fs,dxml_ffts)
     FFT_LOCAL_INIT(nnz, ufb(1), ldz, gs%lorder * nfn, -1)
     
     FFT_MULTIPLE_BACKWARD(nnz, ufb, ldz, gs%lorder * nfn, i, ufb, 1)

     FFT_LOCAL_FREE(-1)
     TIMEDIFF(tzfft, t0)

     TIMEGET(t0)

     ! pdh print out unfold buffer after zFFT
     !
     !      do ifn=0,nfn-1
     !      write(*,*) 'WFN:',ifn+1,' of ',nfn
     !      write(*,*) 'ldz=',ldz
     !      write(*,*) 'gs%lorder=',gs%lorder
     !      write(*,*) 'gs%length=',gs%length
     !      write(*,*) ufb(1+ifn*ldz*gs%lorder:ldz*gs%lorder*(ifn+1))
     !      end do

m4_ifdef([SGI_PC],[
     call fcleardcarray(t1buf(1), nrodst1 * ldy * nfn)
  ],[
  m4_ifdef([HODGKIN],[
     call fcleardcarray(t1buf(1), nrodst1 * ldy * nfn)
  ],[
     t1buf(1:nrodst1 * ldy * nfn) = zzero
  ])
])

     TIMEDIFF(t0t1buf,t0)
     !
     !        do local transpose without any message passing
     !
     TIMEGET(t0)

     do ifn = 0, nfn - 1
        call frepack(gs%packsize(gs%myproc + 1, 2, 1), &
             t1buf(ifn * ldy * nrodst1 + 1), &
             gs%packinfo(1, gs%myproc + 1, 2), &
             ldy * nrodst1, ufb(ifn * ldz * gs%lorder + 1), &
             gs%packinfo(1, gs%myproc + 1, 1), ldz * gs%lorder)
     end do

     TIMEDIFF(tlt1, t0)

     ! pdh print out t1buf buffer after local transpose t1
     !
     !      do ifn=0,nfn-1
     !      write(*,*) 'WFN:',ifn+1,' of ',nfn
     !      write(*,*) 'ldy=',ldy
     !      write(*,*) 'nrodst1=',nrodst1
     !      write(*,*) t1buf(1+ifn*ldy*nrodst1:ldy*nrodst1*(ifn+1))
     !      end do

     !
     !        communication phase to transpose. New grid will be Nx/Nz
     !
m4_ifdef([MPI],[
     TIMEGET(t2)
  m4_ifdef([SHMEM],[
     call barrier() ! all data available?
  ])
     do ip = 1, gs%nproc - 1
        ptarget = mod(ip + gs%myproc, gs%nproc)         ! the target processor
        psource = mod(gs%myproc + gs%nproc - ip, gs%nproc)  ! source processor

  m4_ifdef([SHMEM],[

        call shmem_ixget(ffts%recbuf(1), ufb(1), &
             gs%packinfo(1, psource + 1, 1), gs%packsize(psource + 1, 1, 1), &
             psource)
        do ipack = 1, gs%packsize(psource + 1, 2, 1)
           t1buf(gs%packinfo(ipack, psource + 1, 2)) = &
                ffts%recbuf(ipack)
        end do
  ],[
         !
         !        post a non-blocking receive request to the source processor
         !
        if (gs%packsize(psource + 1, 2, 1) > 0) &
             call mpi_irecv(ffts%recbuf(1), ffts%recbufsize * nfn, &
             MPI_DOUBLE_COMPLEX, psource, psource, MPI_COMM_WORLD, ireqr, ierr)
        !
        !           generate and send off the package for the target processor
        !
    m4_ifdef([MPI_SCATTER],[
        if (gs%packsize(ptarget + 1, 1, 1) > 0) &
             call mpi_isend(ufb(1), nfn, gs%packtype(ptarget + 1), &
             ptarget, gs%myproc, MPI_COMM_WORLD, ireqs, ierr)
    ],[
        do ifn = 0, nfn - 1
           do ipack = 1, gs%packsize(ptarget + 1, 1, 1)
              sendbuf(ipack + ifn * gs%packsize(ptarget + 1, 1, 1)) = &
                   ufb(gs%packinfo(ipack, ptarget + 1, 1) + &
                   ifn * ldz * gs%lorder)
           end do
        end do

        if (gs%packsize(ptarget + 1, 1, 1) > 0) &
             call mpi_isend(sendbuf(1), &
             gs%packsize(ptarget + 1, 1, 1) * nfn, MPI_DOUBLE_COMPLEX, &
             ptarget, gs%myproc, MPI_COMM_WORLD, ireqs, ierr)
    ])
        !     
        !           unpack the package from the neighbor. 
        !
        if (gs%packsize(psource + 1, 2, 1) > 0) &
             call mpi_wait(ireqr, istatus, ierr)      ! wait until packet here
        do ifn = 0, nfn - 1
           do ipack = 1, gs%packsize(psource + 1, 2, 1)
              t1buf(gs%packinfo(ipack, psource + 1, 2) + &
                   ifn * ldy * nrodst1) = &
                   ffts%recbuf(ipack + ifn * gs%packsize(psource + 1, 2, 1))
           end do
        end do
        !
        !              wait until send has completed
        !
        if (gs%packsize(ptarget + 1, 1, 1) > 0) &
             call mpi_wait(ireqs, istatus, ierr)
  ])
     end do
  m4_ifdef([SHMEM],[
     call barrier() ! wait until ubuf is avail
  ])
     TIMEDIFF(tt1,t2)
])
     TIMEGET(t0)
     !
     !        inverse fourier transform in y direction locally 
     !
m4_ifdef([VECTOR],[ 
     call ccfftm(0, nny, nrodst1 * nfn, done, t1buf(1), ldy, t1buf(1), &
          ldy, ffts%workspace(dwy), ffts%workspace(dw2), 0)
     call ccfftm(-1, nny, nrodst1 * nfn, done, t1buf(1), ldy, t1buf(1), &
          ldy, ffts%workspace(dwy), ffts%workspace(dw2), 0) 
])

     FFT_AUX_SPACE(ffts%workspace(dwy), ffts%naux(2), ffts%workspace(dw2), ffts%naux(4), fs, dxml_ffts)
     FFT_LOCAL_INIT(nny, t1buf(1), ldy, nrodst1 * nfn, -1)
     FFT_MULTIPLE_BACKWARD(nny, t1buf, ldy, nrodst1 * nfn, i, t1buf, 1)
     FFT_LOCAL_FREE(-1)
     TIMEDIFF(tyfft, t0)

     ! pdh print out t1buf buffer after yFFT
     !
     !      do ifn=0,nfn-1
     !      write(*,*) 'WFN:',ifn+1,' of ',nfn
     !      write(*,*) 'ldy=',ldy
     !      write(*,*) 'nrodst1=',nrodst1
     !      write(*,*) t1buf(1+ifn*ldy*nrodst1:ldy*nrodst1*(ifn+1))
     !      end do

     !
     !     -------- second transposition phase. grid will be Ny/Nz  ------------
     !                                                       Ny  running faster
     !

     !
     !        clear the array if no fast convolution is wanted
     !
     TIMEGET(t0)
     iofy = gs%fftsize(5) - gs%fftsize(4)

m4_ifdef([FAST_CONVOLUTE],[],[
  m4_ifdef([VECTOR],[
     ffts%unfoldbuf(1:ldx * nrodst2 * nfn) = zzero
  ],[
    m4_ifdef([SR2201],[
     ffts%unfoldbuf(1:ldx * nrodst2 * nfn) = zzero
    ],[
     do ifn = 0, nfn - 1
        do irod = 0, nrodst2 - 1
           i = (irod + ifn * nrodst2) * ldx + 1
           rspace(i + gs%fftsize(4):i + gs%fftsize(5)) = zzero   ! clear array
        end do
     end do
    ])
  ])
])

     TIMEDIFF(t0rspace, t0)
     TIMEGET(t0)
     !
     !        do local transpose
     !
     if (gs%packsize(gs%myproc + 1, 1, 2) > 0) then
        do ifn = 0, nfn - 1
m4_ifdef([CLT2],[
           call fftlt2(-1, gs%chunk(1, 1, 1, gs%myproc + 1), &
                8 * gs%maxnchunk, &
  m4_ifdef([VECTOR],[ffts%unfoldbuf],[rspace])(1 + ifn * ldx * nrodst2), &
                ldx * nrodst2, t1buf(1 + ifn * ldy * nrodst1), ldy * nrodst1, &
                nnx, nny, ldx, ldy)
],[
           ichunk = 1
           do while (.true.)
              srod    = gs%chunk(1, 1, ichunk, gs%myproc + 1)
              sy      = gs%chunk(2, 1, ichunk, gs%myproc + 1) + 1 + &
                   ifn * ldy * nrodst1
              slen    = gs%chunk(3, 1, ichunk, gs%myproc + 1) - 1
              swidth  = abs(gs%chunk(4, 1, ichunk, gs%myproc + 1))
              drod    = gs%chunk(1, 2, ichunk, gs%myproc + 1)
              dx      = gs%chunk(2, 2, ichunk, gs%myproc + 1)
              dlen    = gs%chunk(3, 2, ichunk, gs%myproc + 1) - 1
              do irod = srod, srod + swidth - 1
                 ix = mod(dx + (irod - srod), nnx) + 1 + &
                      ifn * ldx * nrodst2
  m4_ifdef([VECTOR],[
                 ffts%unfoldbuf(drod * ldx + ix: &
                      (drod + dlen) * ldx + ix:ldx) = &
                      t1buf(irod * ldy + sy:irod * ldy + sy + slen)
  ],[
    m4_ifdef([SR2201],[
                 ffts%unfoldbuf(drod * ldx + ix: &
                      (drod + dlen) * ldx + ix:ldx) = &
                      t1buf(irod * ldy + sy:irod * ldy + sy + slen)
    ],[
            call mzcopy(slen + 1,t1buf(irod * nny + sy), 1, &
                 rspace(drod * nnx + ix), nnx) 
!                 rspace(drod * nnx + ix:(drod + dlen) * nnx + ix:nnx) = &
!                      t1buf(irod * nny + sy:irod * nny + sy + slen)
    ])
  ])
              end do
              if (gs%chunk(4, 1, ichunk, gs%myproc + 1) < 0) exit
              ichunk = ichunk + 1
           end do
])
        end do
     endif
     TIMEDIFF(tlt2, t0)

     ! pdh print out rspace buffer after local transpose t2
     !
     !      do ifn=0,nfn-1
     !      write(*,*) 'WFN:',ifn+1,' of ',nfn
     !      write(*,*) 'ldx=',ldx
     !      write(*,*) 'nrodst2=',nrodst2
     !      write(*,*) rspace(1+ifn*ldx*nrodst2:ldx*nrodst2*(ifn+1))
     !      end do

     !
     !        communicate with the other processors.
     !

m4_ifdef([MPI],[
     TIMEGET(t0)
     !
     !        First pack all the packets to all processors
     !        In case mpi is used, also send out immediately
     !
     poffset = 1 ; npacksend = 0
     do ip = 1, gs%nproc - 1
        ptarget = mod(ip + gs%myproc, gs%nproc)         ! the target processor
        if (gs%packsize(ptarget + 1, 1, 2) > 0) then
           ichunk = 1
           ipack = poffset
           do while (.true.)
              srod    = gs%chunk(1, 1, ichunk, ptarget + 1)
              sy      = gs%chunk(2, 1, ichunk, ptarget + 1) + 1
              slen    = gs%chunk(3, 1, ichunk, ptarget + 1) - 1
              swidth  = abs(gs%chunk(4, 1, ichunk, ptarget + 1))
              do ifn = 0, nfn - 1
                 do irod = srod, srod + swidth - 1
                   call mzcopy(slen + 1, t1buf(irod * ldy + sy), 1, &
                    sendbuf(poffset), 1 ) 
!                    sendbuf(poffset:poffset + slen) = &
!                         t1buf(irod * ldy + sy:irod * ldy + sy + slen)
                    poffset = poffset + slen + 1
                 end do
                 sy = sy + ldy * nrodst1
              end do
              if (gs%chunk(4, 1, ichunk, ptarget + 1) < 0) exit
              ichunk = ichunk + 1
           end do
  m4_ifdef([SHMEM2],[],[
           npacksend = npacksend + 1
           call mpi_isend(sendbuf(ipack), &
                nfn * gs%packsize(ptarget + 1, 1, 2), &
                MPI_DOUBLE_COMPLEX, ptarget, gs%myproc, MPI_COMM_WORLD, &
                ffts%mpireq(npacksend), ierr)
  ])
        end if
     end do                 ! loop over all packets to other processors
])
m4_ifdef([MPI],[
  m4_ifdef([SHMEM2],[
     call barrier()         ! everybody done packing?
  ])
     !
     !        now get the data from the other processor
     !
     !
     !        The MPI code has room for improvement here. One should just
     !        pull in the messages, read the tag, and dispatch accordingly.
     !
     !
     do ip = 1, gs%nproc - 1
        psource = mod(gs%myproc + gs%nproc - ip, gs%nproc) ! source processor
        if (gs%packsize(psource + 1, 2, 2) > 0) then
  m4_ifdef([SHMEM2],[
           !              for shmem, get directly from source proc
           call shmem_get(ffts%recbuf(1), sendbuf(gs%pickup(psource + 1, 1)), &
                gs%packsize(psource + 1, 2, 2) * 2, psource)
  ],[
           !              for MPI, do a blocking receive on the source proc
           call mpi_recv(ffts%recbuf(1), ffts%recbufsize * nfn, &
                MPI_DOUBLE_COMPLEX, psource, psource, &
                MPI_COMM_WORLD, istatus, ierr)
  ])
           !
           !              unpack the received data
           !
           ichunk = 1
           poffset = 1
           do while (.true.)
              drod    = gs%chunk(1, 2, ichunk, psource +1 )
              dx      = gs%chunk(2, 2, ichunk, psource +1 )
              dlen    = gs%chunk(3, 2, ichunk, psource +1 ) - 1
              dwidth  = abs(gs%chunk(4, 2, ichunk, psource + 1))
              do ifn = 0 , nfn - 1
                 do j = 0, dwidth - 1
                    ix = mod(dx + j, nnx) + 1 + ifn * ldx * nrodst2
  m4_ifdef([SR2201],[
                    ffts%unfoldbuf(drod * ldx + ix:(drod + dlen) * ldx + ix: &
                         ldx) = ffts%recbuf(poffset:poffset + dlen)
  ],[
                     call mzcopy(dlen + 1, ffts%recbuf(poffset), 1, &
                        rspace(drod * ldx + ix), ldx ) 
!                    rspace(drod * ldx + ix:(drod + dlen) * ldx + ix: &
!                         ldx) = ffts%recbuf(poffset:poffset + dlen)
  ])
                    poffset = poffset + dlen + 1
                 end do
              end do
              if (gs%chunk(4, 2, ichunk, psource + 1) < 0) exit
              ichunk = ichunk + 1
           end do
        end if
     end do                 ! loop over processors
  m4_ifdef([SHMEM2],[
     call barrier()         ! wait before deallocation
  ],[
     if (npacksend > 0) call mpi_waitall(npacksend, &
          ffts%mpireq(1), ffts%mpistat(1), ierr) 
  ])
     TIMEDIFF(tt2, t0)
])
  else
     !
     !     ================   FROM REALSPACE TO GSPACE ===================
     !
     !                        (forward FFT)
     !
     !
     !     ---------------- second transposition phase -----------------------
     !                 (really the first transpose for the forward FFT)

     !
     !     do local transpose without any message passing
     !

     ! pdh print out rspace buffer before local transpose t2
     !
     !      do ifn=0,nfn-1
     !      write(*,*) 'WFN:',ifn+1,' of ',nfn
     !      write(*,*) 'ldx=',ldx
     !      write(*,*) 'nrodst2=',nrodst2
     !      write(*,*) rspace(1+ifn*ldx*nrodst2:ldx*nrodst2*(ifn+1))
     !      end do

     TIMEGET(t0)
     if (gs%packsize(gs%myproc + 1, 1, 2) > 0) then
        do ifn = 0, nfn - 1
m4_ifdef([CLT2],[
           call fftlt2(1, gs%chunk(1, 1, 1, gs%myproc + 1), &
                8*gs%maxnchunk, &
  m4_ifdef([VECTOR],[ffts%unfoldbuf],[rspace])(1 + ifn * ldx * nrodst2), &
                ldx * nrodst2, ffts%t1buf(1 + ifn * ldy * nrodst1), &
                ldy * nrodst1, nnx, nny, ldx, ldy)
],[
           ichunk = 1
           do while (.true.)
              srod    = gs%chunk(1, 1, ichunk, gs%myproc + 1)
              sy      = gs%chunk(2, 1, ichunk, gs%myproc + 1) + 1 + &
                   ifn * ldy * nrodst1
              slen    = gs%chunk(3, 1, ichunk, gs%myproc + 1) - 1
              swidth  = abs(gs%chunk(4, 1, ichunk, gs%myproc + 1))
              drod    = gs%chunk(1, 2, ichunk, gs%myproc + 1)
              dx      = gs%chunk(2, 2, ichunk, gs%myproc + 1)
              dlen    = gs%chunk(3, 2, ichunk, gs%myproc + 1) - 1
              do irod = srod, srod + swidth - 1
                 ix = mod(dx + (irod - srod), nnx) + 1 + &
                      ifn * ldx * nrodst2
  m4_ifdef([VECTOR],[
                 ffts%t1buf(irod * ldy + sy:irod * ldy + sy + slen) = &
                      ffts%unfoldbuf(drod * ldx + ix: &
                      drod * ldx + dlen * ldx + ix:ldx)
  ],[
    m4_ifdef([SR2201],[
                 ffts%t1buf(irod * ldy + sy:irod * ldy + sy + slen) = &
                      ffts%unfoldbuf(drod * ldx + ix: &
                      (drod + dlen) * ldx + ix:ldx)
    ],[
                   call mzcopy(slen + 1, rspace(drod * nnx + ix), nnx, &
                         t1buf(irod * nny + sy), 1 ) 
!                 ffts%t1buf(irod * nny + sy:irod * nny + sy + slen) = &
!                      rspace(drod * nnx + ix:(drod + dlen) * nnx + ix:nnx)
    ])
  ])
              end do
              if (gs%chunk(4, 1, ichunk, gs%myproc + 1) < 0) exit
              ichunk = ichunk + 1
           end do
])
        end do
     end if
     TIMEDIFF(tlt2, t0)
     !
     !        now communicate (t2 forward FFT)
     !
     TIMEGET(t0)
m4_ifdef([MPI],[
     !
     !        First pack all the packets to all processors
     !        In case mpi is used, also send out immediately
     !
     poffset = 1 ; npacksend = 0
     do ip = 1, gs%nproc - 1
        ptarget = mod(ip + gs%myproc, gs%nproc)         ! the target processor
        if (gs%packsize(ptarget + 1, 2, 2) > 0) then
           ichunk = 1
           ipack = poffset
           do while(.true.)
              drod    = gs%chunk(1, 2, ichunk, ptarget + 1)
              dx      = gs%chunk(2, 2, ichunk, ptarget + 1)
              dlen    = gs%chunk(3, 2, ichunk, ptarget + 1) - 1
              dwidth  = abs(gs%chunk(4, 2, ichunk, ptarget + 1))
              do ifn = 0, nfn - 1
                 do j = 0, dwidth - 1
                    ix = mod(dx + j, nnx) + 1 + ifn * ldx * nrodst2
  m4_ifdef([SR2201],[
                    sendbuf(poffset:poffset + dlen) = &
                         ffts%unfoldbuf(drod * ldx + ix: &
                         (drod + dlen) * ldx + ix:ldx)
  ],[
                     call mzcopy(dlen + 1, rspace(drod * ldx + ix), ldx, &
                            sendbuf(poffset), 1 ) 
  ])
                    poffset = poffset + dlen + 1
                 end do
              end do
              if (gs%chunk(4, 2, ichunk, ptarget + 1) < 0) exit
              ichunk = ichunk + 1
           end do

  m4_ifdef([SHMEM3],[],[
           npacksend = npacksend + 1
           call mpi_isend(sendbuf(ipack), &
                nfn * gs%packsize(ptarget + 1, 2, 2), &
                MPI_DOUBLE_COMPLEX, ptarget, gs%myproc, &
                MPI_COMM_WORLD, ffts%mpireq(npacksend), ierr)
  ])
        end if
     end do                 ! loop over all packets to other procs
     !
     !        now get the data from the other processor
     !
     !        The MPI code has room for improvement here. One should just
     !        pull in the messages, read the tag, and dispatch accordingly.
     !
     !
  m4_ifdef([SHMEM3],[
     call barrier()            ! everybody done packing?
  ])
     do ip = 1, gs%nproc - 1
        psource = mod(gs%myproc + gs%nproc - ip, gs%nproc)   ! the source proc
        if (gs%packsize(psource + 1, 1, 2) > 0) then
  m4_ifdef([SHMEM3],[
           !              for shmem, get directly from source proc
           call shmem_get(ffts%recbuf(1), &
                sendbuf(gs%pickup(psource + 1, 2)), &
                gs%packsize(psource + 1, 1, 2) * 2, psource)
  ],[
           !              for MPI, do a blocking receive on the source proc
           call mpi_recv(ffts%recbuf(1), ffts%recbufsize * nfn, &
                MPI_DOUBLE_COMPLEX, psource, psource, &
                MPI_COMM_WORLD, istatus, ierr)
  ])
           !
           !         unpack the package from the neighbor. The packinfo array
           !         gives the index for the incoming data.
           !
           ichunk = 1
           poffset = 1
           do while (.true.)
              srod    = gs%chunk(1, 1, ichunk, psource + 1)
              sy      = gs%chunk(2, 1, ichunk, psource + 1) + 1
              slen    = gs%chunk(3, 1, ichunk, psource + 1) - 1
              swidth  = abs(gs%chunk(4, 1, ichunk, psource + 1))
              do ifn = 0, nfn - 1
                 do irod = srod, srod + swidth - 1
                    call mzcopy(slen + 1, ffts%recbuf(poffset), 1, &
                      ffts%t1buf(irod * ldy + sy), 1 ) 
                    poffset = poffset + slen + 1
                 end do
                 sy = sy + ldy * nrodst1
              end do
              if (gs%chunk(4, 1, ichunk, psource + 1) < 0) exit
              ichunk = ichunk + 1
           end do
        end if
     end do                 ! loop over processors

     !        make sure the send buffer can be deallocated
  m4_ifdef([SHMEM3],[
     call barrier()
  ],[
     if (npacksend > 0) call mpi_waitall(npacksend, &
          ffts%mpireq(1), ffts%mpistat(1), ierr) 
  ])
     TIMEDIFF(tt2, t0)
])

     ! pdh print out t1buf buffer after yFFT
     !
     !      do ifn=0,nfn-1
     !      write(*,*) 'WFN:',ifn+1,' of ',nfn
     !      write(*,*) 'ldy=',ldy
     !      write(*,*) 'nrodst1=',nrodst1
     !      write(*,*) t1buf(1+ifn*ldy*nrodst1:ldy*nrodst1*(ifn+1))
     !      end do

     !
     !        fourier transform in y direction locally 
     !
     TIMEGET(t0)
m4_ifdef([VECTOR],[
     call ccfftm(0, nny, nrodst1 * nfn, done, ffts%t1buf(1), &
          ldy, ffts%t1buf(1), ldy, ffts%workspace(dwy), &
          ffts%workspace(dw2), 0)
     call ccfftm(1, nny, nrodst1 * nfn, done, ffts%t1buf(1), &
          ldy, ffts%t1buf(1), ldy, ffts%workspace(dwy), &
          ffts%workspace(dw2), 0) 
])

     TIMEGET(t0)

     FFT_AUX_SPACE(ffts%workspace(dwy), ffts%naux(2), ffts%workspace(dw2), ffts%naux(4), fs, dxml_ffts)
     FFT_LOCAL_INIT(nny, ffts%t1buf(1), ldy, nrodst1 * nfn, 1)
     FFT_MULTIPLE_FORWARD(nny, ffts%t1buf, ldy, nrodst1 * nfn, i, ffts%t1buf, 1)
     FFT_LOCAL_FREE(1)
     TIMEDIFF(tyfft, t0)
     !
     !     --------------------- first transpose --------------------
     !
     !
     !        do local transpose without any message passing
     !
     TIMEGET(t0)

     do ifn = 0, nfn - 1
        call frepack(gs%packsize(gs%myproc + 1, 2, 1), &
             ufb(ifn * ldz * gs%lorder + 1), &
             gs%packinfo(1, gs%myproc+1, 1), ldz * gs%lorder, &
             ffts%t1buf(ifn * ldy * nrodst1 + 1), &
             gs%packinfo(1, gs%myproc + 1, 2), ldy * nrodst1)
     end do

     TIMEDIFF(tlt1, t0)

m4_ifdef([MPI],[
     TIMEGET(t0)
  m4_ifdef([SHMEM],[
     call barrier()
  ])
     do ip = 1, gs%nproc - 1
        ptarget = mod(ip + gs%myproc, gs%nproc)         ! the target processor
        psource = mod(gs%myproc + gs%nproc - ip, gs%nproc)  ! source processor
  m4_ifdef([SHMEM],[
        do ipack = 1, gs%packsize(ptarget + 1, 2, 1)
           sendbuf(ipack) = &
                ffts%t1buf(gs%packinfo(ipack, ptarget + 1, 2))
        end do
        call barrier() 
        call shmem_ixput(ufb(1), sendbuf(1), &
             gs%packinfo(1, ptarget + 1, 1), &
             gs%packsize(ptarget + 1, 1, 1), ptarget)
  ],[
        !
        !           post a non-blocking receive request to the source processor
        !
        if (gs%packsize(psource + 1, 1, 1) > 0) &
             call mpi_irecv(ffts%recbuf(1), ffts%recbufsize * nfn, &
             MPI_DOUBLE_COMPLEX, psource, psource, &
             MPI_COMM_WORLD, ireqr, ierr)
        !
        !           generate and send off the package for the target processor
        !
        if (gs%packsize(ptarget + 1, 2, 1) > 0) then
           do ifn = 0, nfn - 1
              do ipack = 1, gs%packsize(ptarget + 1, 2, 1)
                 sendbuf(ipack + ifn * gs%packsize(ptarget + 1, 2, 1)) = &
                      ffts%t1buf(gs%packinfo(ipack, ptarget + 1, 2) + &
                      ifn * ldy * nrodst1)
              end do
           end do
           call mpi_isend(sendbuf(1), gs%packsize(ptarget + 1, 2, 1) * nfn, &
                MPI_DOUBLE_COMPLEX, ptarget, gs%myproc, &
                MPI_COMM_WORLD, ireqs, ierr)
        end if
        !
        !           unpack the package from the neighbor. 
        !
        if (gs%packsize(psource + 1, 1, 1) > 0) then
           call mpi_wait(ireqr, istatus, ierr)        ! wait until packet here
           do ifn = 0, nfn - 1
              do ipack = 1, gs%packsize(psource + 1, 1, 1)
                 ufb(gs%packinfo(ipack, psource + 1, 1) + ifn * ldz * &
                      gs%lorder) = ffts%recbuf(ipack + ifn * &
                      gs%packsize(psource + 1, 1, 1))
              end do
           end do
        end if
        !
        !           wait until send has completed
        !
        if (gs%packsize(ptarget + 1, 2, 1) > 0) &
             call mpi_wait(ireqs, istatus, ierr)
  ])
     end do
  m4_ifdef([SHMEM],[
     call barrier()
  ])
     TIMEDIFF(tt1, t0)
])
     !
     !     ---- fourier transform in z direction locally ----
     !
     TIMEGET(t0)
     m4_ifdef([VECTOR],[ 
     call ccfftm(0, nnz, gs%lorder * nfn, done, ufb(1), &
          ldz, ufb(1), ldz, ffts%workspace(dwz), &
          ffts%workspace(dw2), 0)
     call ccfftm(1, nnz, gs%lorder * nfn, done, ufb(1), &
          ldz, ufb(1), ldz, ffts%workspace(dwz), &
          ffts%workspace(dw2), 0) 
])
     FFT_AUX_SPACE(ffts%workspace(dwz), ffts%naux(3), ffts%workspace(dw2), ffts%naux(4), fs, dxml_ffts)
     FFT_LOCAL_INIT(nnz, ufb(1), ldz, gs%lorder * nfn, 1)
     FFT_MULTIPLE_FORWARD(nnz, ufb, ldz, gs%lorder * nfn, i, ufb, 1)
     FFT_LOCAL_FREE(1)

     TIMEDIFF(tzfft, t0)

     !        Set the data up for the first fourier transform.
     !        All the rods on this processor are put next to each other
     !        into the unfold buffer, and then fourier transformed with 
     !        a block routine for optimum performance.
     ! 
     TIMEGET(t0)
     call fftfold(gsdat(1), gs, ufb(1), ldz, nfn)
     TIMEDIFF(tunfold, t0)
  end if

m4_ifdef([SHMEM],[
  call shpdeallc(t1buf_p, ierr, -1)
  call shpdeallc(ufb_p, ierr, -1)
  call shpdeallc(sendbuf_p, ierr, -1)
])

  return

100 format('TIME FOR ',a30,':',f12.6)

end subroutine fourier_transform_12
!
!     ======================================================================
!
subroutine fourier_transform_3(idir, ffts, gs, rspace, nfn)
  !
  !
  include 'use.h'
  implicit none             ! implicit? Just say no!
m4_ifdef([MPI],[include 'mpif.h'])
  include 'interface.h'
m4_ifdef([TIMING],[include 'timing.h'])
  !
  !     INPUT:
  !     -----
  !
  integer, intent(in) :: idir                     ! if >=0  rspace ==> gspace
                                                  ! if <0   rspace <== gspace
  integer, intent(in) :: nfn                     ! number of functions to FFT
  type(fft_struc), intent(in) :: ffts               ! work arrays for the FFT
  type(parallel_gspace), intent(in) :: &
       gs                           ! the gspace for which the data is set up
  !
  !     INPUT/OUTPUT:
  !     ------------
  !
  complex(dp), intent(inout) :: &
       rspace(gs%r_size * nfn)! the data in realspace rspace(ffts%r_size)
  !                                 on the cray pvp, this is untouched, and the
  !                                 output is in ffts%unfoldbuf
  !
  !     DESCRIPTION:
  !     -----------
  !
  !     performs the first stage of a forward or the last stage of an
  !     inverse 3dFFT.
  !
  !     ON THE VECTOR MACHINES, THE OUTPUT IS ACTUALLY RETURNED IN 
  !     THE FFTS%UNFOLDBUF ARRAY. This is because on the vector
  !     machines, the stride should not be a power of two, but that is
  !     likely to be the case for a nice FFT grid.
  !
  !
  !
  integer :: i, j, nnx, nny, nnz, nrodst2, dwx, dw2, ldx, ldy, ldz, &
       nz, ny, k, ierr, ifn
  real(dp) :: t0
  real(dp), external :: gimmetime

  FFT_HEADER

  nnx = gs%fftsize(1) ; nny = gs%fftsize(2) ; nnz = gs%fftsize(3)
  nrodst2 = (nny * nnz) / gs%nproc 
  if (mod(nny * nnz, gs%nproc) > gs%myproc) nrodst2 = nrodst2 + 1
  dwx = 1 ; dw2 = ffts%naux(1) + ffts%naux(2) + ffts%naux(3) + 1
  ldx = nnx ; ldy = nny ; ldz = nnz

m4_ifdef([VECTOR],[
  if (mod(ldx, 2) == 0) ldx = ldx + 1
  if (mod(ldy, 2) == 0) ldy = ldy + 1
  if (mod(ldz, 2) == 0) ldz = ldz + 1
])
m4_ifdef([SR2201],[
  if (mod(ldx, 2) == 0) ldx = ldx + 1
  if (mod(ldy, 2) == 0) ldy = ldy + 1
  if (mod(ldz, 2) == 0) ldz = ldz + 1
])

  if (idir < 0) then ! from gspace to realspace
     !
     !           inverse fourier transform in x direction locally
     !
     !     
     TIMEGET(t0)
     FFT_AUX_SPACE(ffts%workspace(dwx), ffts%naux(1), ffts%workspace(dw2), ffts%naux(4), fs, dxml_ffts)
m4_ifdef([FAST_CONVOLUTE],[
     FFT_LOCAL_INIT(nnx, rspace(1), ldx, 1, -1)
     do ifn = 0, nfn - 1
        do i = 0, nrodst2 - 1
           j = i * nnx + 1 + ifn * nrodst2 * nnx
           if (gs%fftsize(5) > gs%fftsize(4) + 1) &
                rspace(j + gs%fftsize(4) + 1:j + gs%fftsize(5) - 1) = zzero
           FFT_BACKWARD(nnx, rspace(j), ldx)
        end do
     end do
],[
     FFT_LOCAL_INIT(nnx, rspace(1), ldx, nrodst2*nfn, -1)
m4_ifdef([SR2201],[
     FFT_MULTIPLE_BACKWARD(nnx, ffts%unfoldbuf(1), ldx, nrodst2 * nfn, i, ffts%unfoldbuf, 1)
     do ifn = 0, nfn - 1
        do i = 0, nrodst2 - 1
           do j = 1, nnx
              rspace(i * nnx + j + ifn * nrodst2 * nnx) = &
                   ffts%unfoldbuf(ifn * ldx * nrodst2 + i * ldx + j)
           end do
        end do
     end do
],[
     FFT_MULTIPLE_BACKWARD(nnx, rspace, ldx, nrodst2 * nfn, i, ffts%unfoldbuf, 1)
])
])
     FFT_LOCAL_FREE(-1)

m4_ifdef([VECTOR],[ 
     call ccfftm(0, nnx, nrodst2 * nfn, done, ffts%unfoldbuf(1), &
          ldx, rspace(1), nnx, ffts%workspace(dwx), ffts%workspace(dw2), 0)
     call ccfftm(-1, nnx, nrodst2 * nfn, done, ffts%unfoldbuf(1), & 
          ldx, rspace(1), nnx, ffts%workspace(dwx), ffts%workspace(dw2), 0) 
])

     TIMEDIFF(txfft, t0)

  else                      ! -------------- forward FFT ------------

     !
     !        fourier transform in x direction locally
     !
     TIMEGET(t0)
     FFT_AUX_SPACE(ffts%workspace(dwx), ffts%naux(1), ffts%workspace(dw2), ffts%naux(4), fs, dxml_ffts)
     FFT_LOCAL_INIT(nnx, rspace(1), ldx, nrodst2 * nfn, 1)
m4_ifdef([SR2201],[
     do ifn = 0, nfn - 1
        do i = 0, nrodst2 - 1
           do j = 1, nnx
              ffts%unfoldbuf(ifn * ldx * nrodst2 + i * ldx + j) = &
                   rspace(ifn * nnx * nrodst2 + i * nnx + j)
           end do
        end do
     end do
     FFT_MULTIPLE_FORWARD(nnx, ffts%unfoldbuf(1), ldx, nrodst2 * nfn, i, ffts%unfoldbuf, 1) 
],[
     FFT_MULTIPLE_FORWARD(nnx, rspace, ldx, nrodst2 * nfn, i, ffts%unfoldbuf, 1)
])
     FFT_LOCAL_FREE(1)

m4_ifdef([VECTOR],[
     call ccfftm(0, nnx, nrodst2 * nfn, done, rspace(1), &
          nnx, ffts%unfoldbuf(1), ldx, ffts%workspace(dwx), &
          ffts%workspace(dw2), 0)
     call ccfftm(1, nnx, nrodst2 * nfn, done, rspace(1), &
          nnx, ffts%unfoldbuf(1), ldx, ffts%workspace(dwx), &
          ffts%workspace(dw2), 0) 
])

     TIMEDIFF(txfft, t0)

  end if

  return

end subroutine fourier_transform_3
!
!     ======================================================================
!
subroutine fast_convolute(ffts, gs, gsdat, vgsdat, rspace, vloc)
  !
  !
  include 'use.h'
  implicit none             ! implicit? Just say no!
m4_ifdef([MPI],[include 'mpif.h'])
  include 'interface.h'
m4_ifdef([TIMING],[include 'timing.h'])
  !
  !     INPUT:
  !     -----
  !
  type(fft_struc), intent(in) :: ffts                ! work arrays for the FFT
  type(parallel_gspace), intent(in) :: &
       gs                            ! the gspace for which the data is set up
  complex(dp), intent(in) :: vloc(ffts%r_size)           ! realspace potential
  !
  !     INPUT/OUTPUT:
  !     ------------
  !
  complex(dp), intent(inout) :: &
       rspace(gs%r_size)           ! the data in realspace rspace(ffts%r_size)
  complex(dp), intent(inout) :: &
       gsdat(gs%length)                  ! the data in gspace gsdat(gs%length)
  !
  !     OUTPUT:
  !     ------
  !
  complex(dp), intent(inout) :: &
       vgsdat(gs%length)            ! the data in gspace multiplied with vloc
  !                                                         vgsdat(gs%length)
  !
  !     DESCRIPTION:
  !     -----------
  !
  !     performs the last stage of the inverse FFT, multiplies with
  !     vloc, and does the first stage of the forward FFT
  !
  integer :: &
       i, j, k, nnx, nny, nnz, nrodst2, dwx, dw2, ldx, ldy, ldz, nblock, n, &
       ifn
  real(dp) :: t0
  complex(dp), allocatable :: work(:)
  real(dp), external :: gimmetime

  FFT_HEADER

  nnx = gs%fftsize(1) ; nny = gs%fftsize(2) ; nnz = gs%fftsize(3)
  nrodst2 = (nny * nnz) / gs%nproc 
  if (mod(nny * nnz, gs%nproc) > gs%myproc) nrodst2 = nrodst2 + 1
  dwx = 1 ; dw2 = ffts%naux(1) + ffts%naux(2) + ffts%naux(3) + 1
  nblock = 1
  ldx = nnx ; ldy = nny ; ldz = nnz
m4_ifdef([VECTOR],[
  if (mod(ldx, 2) == 0) ldx = ldx + 1
  if (mod(ldy, 2) == 0) ldy = ldy + 1
  if (mod(ldz, 2) == 0) ldz = ldz + 1
])
m4_ifdef([SR2201],[
  if (mod(ldx, 2) == 0) ldx = ldx + 1
  if (mod(ldy, 2) == 0) ldy = ldy + 1
  if (mod(ldz, 2) == 0) ldz = ldz + 1
])

  TIMEGET(t0)

  nblock = FFT_FCBLOCK

m4_ifdef([RS6K],[
  allocate(work(ffts%naux(1)))
  FFT_AUX_SPACE(work(1), ffts%naux(1), ffts%workspace(dw2), ffts%naux(4), fs, dxml_ffts)
  FFT_LOCAL_INIT(nnx, rspace(1), ldx, nblock, 1)
])

  FFT_AUX_SPACE(ffts%workspace(dwx), ffts%naux(1), ffts%workspace(dw2), ffts%naux(4), fs, dxml_ffts)
  FFT_LOCAL_INIT(nnx, rspace(1), ldx, nblock, -1)
  !
  !     now do the blocked loop
  !
  do i = 0, nrodst2 - nblock, nblock
     j = i * ldx + 1
     if (gs%fftsize(5) > gs%fftsize(4) + 1) then
        do n = 0, nblock - 1     ! clear the array
           rspace(n * ldx + j + gs%fftsize(4) + 1: &
                n * ldx + j + gs%fftsize(5) - 1) = zzero
        end do
     end if
     FFT_AUX_SPACE(ffts%workspace(dwx), ffts%naux(1), ffts%workspace(dw2), ffts%naux(4), fs, dxml_ffts)

m4_ifdef([HAS_MULT_FFT],[
     FFT_MULTIPLE_BACKWARD(nnx, rspace, ldx, nblock, j, rspace, 1 + i * nnx)
],[
     FFT_BACKWARD(nnx, rspace(1 + nnx * i), ldx)
])
     !
     !        mult with realspace potential
     !
     FFT_CONVOL(nnx * nblock, rspace, vloc, j, 1)
     !
     !        generic loop for arbitrary block size
     !         do n=0,nblock-1    
     !            rspace(j+n*ldx:j+n*ldx+nnx-1)= &
     !             rspace(j+n*ldx:j+n*ldx+nnx-1)*vloc(j+n*ldx:j+n*ldx+nnx-1)
     !         end do
     !
m4_ifdef([RS6K],[
     FFT_AUX_SPACE(work(1), ffts%naux(1), ffts%workspace(dw2), ffts%naux(4), fs, dxml_ffts)
])

m4_ifdef([HAS_MULT_FFT],[
     FFT_MULTIPLE_FORWARD(nnx, rspace, ldx, nblock, j, rspace, 1 + i * nnx)
],[
     FFT_FORWARD(nnx, rspace(1 + nnx * i), ldx)
])
  end do
  FFT_LOCAL_FREE(1)

m4_ifdef([RS6K],[
  FFT_AUX_SPACE(work(1), ffts%naux(1), ffts%workspace(dw2), ffts%naux(4), fs, dxml_ffts)
  FFT_LOCAL_INIT(nnx, rspace(1), ldx, 1, 1)
])

  FFT_AUX_SPACE(ffts%workspace(dwx), ffts%naux(1), ffts%workspace(dw2), ffts%naux(4), fs, dxml_ffts)
  FFT_LOCAL_INIT(nnx, rspace(1), ldx, 1, -1)
  !
  !     now finish off what is left
  !
  k = i
  do i = k, nrodst2 - 1
     j = i * nnx + 1
     if (gs%fftsize(5) > gs%fftsize(4) + 1) &
          rspace(j + gs%fftsize(4) + 1:j + gs%fftsize(5) - 1) = zzero
     FFT_AUX_SPACE(ffts%workspace(dwx), ffts%naux(1), ffts%workspace(dw2), ffts%naux(4), fs, dxml_ffts)
     FFT_BACKWARD(nnx, rspace(1 + nnx * i), ldx)

     FFT_CONVOL(nnx, rspace, vloc, j, 1)

m4_ifdef([RS6K],[
     FFT_AUX_SPACE(work(1), ffts%naux(1), ffts%workspace(dw2), ffts%naux(4), fs, dxml_ffts)
])
     FFT_FORWARD(nnx, rspace(1 + nnx * i), ldx)
  end do

  FFT_LOCAL_FREE(1)

m4_ifdef([RS6K],[
  deallocate(work)
])

  TIMEDIFF(txfft, t0)

  return

end subroutine fast_convolute
!
!     ======================== SERVICE ROUTINES ==========================
!
subroutine fftunfold(folded, gs, unfolded, ldz, nfn)

  include 'use.h'
  implicit none             ! implicit? Just say no!
  include 'interface.h'
  !
  !     INPUT:
  !     -----
  !
  type(parallel_gspace), intent(in) :: gs            ! the gspace for the data
  integer, intent(in) :: &
       ldz, &                                              ! leading dimension
       nfn                         ! number of functions to FFT simultaneously
  complex(dp), intent(in) :: &
       folded(gs%length, nfn)                             ! the data in gspace
  !
  !     OUTPUT:
  !     ------
  !
  complex(dp), intent(out) :: &
       unfolded(ldz, gs%lorder, nfn)
  !
  !     the unfold array must have the size Nz* number of rods held by
  !     this proc, i.e. nfn * gs%lorder * Nz
  !
  !
  !     DESCRIPTION:
  !     -----------
  !
  !     Transfers the rods from the packed gspace arrangement onto
  !     a linear grid of length gs%fftsize(3), such that a subsequent
  !     1d FFT can be performed
  !
  !     ----------------- local variables -----------------------
  !
  integer :: i, ii, nz, iord, istart, iend, iid, it, ifn

  unfolded = zzero                ! blank out target array

  !
  !     do not remove the it variable. It helps to circumvent a
  !     compiler bug on the SGI PowerChallenge Fortran 90 v.7.0
  !     
  !

  nz = gs%fftsize(3)

  do ifn = 1, nfn

     ii = 1
     it = 0
     do iord = 1, gs%lorder
        istart = gs%order(2, iord)
        iend   = gs%order(3, iord)
        it = it + iend
        if (istart <= iend) then         ! only one contiguous block to copy:
           iid    = ii + mod(iend - istart + nz, nz)
           unfolded(istart + 1:iend + 1, iord, ifn) = &
                folded(ii:iid, ifn)
        else                             ! two blocks to copy
           iid    = ii + nz - istart - 1
           unfolded(istart + 1:nz, iord, ifn) = &
                folded(ii:iid, ifn)
           ii     = iid + 1
           iid    = ii + iend
           unfolded(1:iend + 1, iord, ifn) = &
                folded(ii:iid, ifn)
        end if

        ii = iid + 1             ! new start  =    old end +1

     end do

  end do

  if (it < 0) write(9, *) it

end subroutine fftunfold


!     -----------------------------------------------------------------------

subroutine fftfold(folded, gs, unfolded, ldz, nfn)
  !
  include 'use.h'
  implicit none             ! implicit? Just say no!
  include 'interface.h'
  !
  !     1996 Bernd Pfrommer
  !
  !     INPUT:
  !     -----

  type(parallel_gspace), intent(in) :: gs           ! the gspace for the data
  integer, intent(in) :: ldz, nfn
  complex(dp), intent(in) :: &
       unfolded(ldz, gs%lorder, nfn)
  !
  !     OUTPUT:
  !     ------
  !
  complex(dp), intent(out) :: &
       folded(gs%length, nfn)                           ! the data in gspace

  !     DESCRIPTION:
  !     -----------
  !
  !     Collects the data from a 1d grid into the packed gspace
  !     arrangement.
  !
  !     Scales the result by   1/nx*ny*nz, except for the alpha and convex
  !
  !     the unfold array must have the size Nz* number of rods held by
  !     this proc, i.e. nfn * gs%lorder * Nz.
  !
  !     the fold array must have the length of the gspace
  !
  !
  !     ----------------- local variables -----------------------
  !
  integer :: i, ii, nz, iord, istart, iend, iid, it, ifn
  !
  !     do not remove the it variable. It helps to circumvent a
  !     compiler bug on the SGI PowerChallenge Fortran 90 v.7.0
  !
  real(dp) :: sc

  sc = done / real(gs%fftsize(1) * gs%fftsize(2) * gs%fftsize(3), dp)
m4_ifdef([ALPHA],[
  sc = done
])
m4_ifdef([CVX],[
  sc = done
])

  nz = gs%fftsize(3)

  do ifn = 1, nfn

     ii = 1
     it = 0
     do iord = 1, gs%lorder
        istart = gs%order(2, iord)
        iend   = gs%order(3, iord)
        it = it + iend
        if(istart <= iend) then           ! only one contiguous block to copy:
           iid    = ii + mod(iend - istart + nz, nz)
           folded(ii:iid, ifn) = unfolded(istart + 1:iend + 1, iord, ifn) * sc
        else                                    ! there are two blocks to copy
           iid    = ii + nz - istart - 1
           folded(ii:iid, ifn) = unfolded(istart + 1:nz, iord, ifn) * sc
           ii     = iid + 1
           iid    = ii + iend
           folded(ii:iid, ifn) = unfolded(1:iend + 1, iord, ifn) * sc
        end if
        ii = iid + 1          ! new start  =    old end +1
     end do
  end do

  if (it < 0) write(9, *) it

end subroutine fftfold

!
!     ============================================================

subroutine fft_convolute(gs, ffts, vpsi, vloc, psi, nwfn)
  !
  include 'use.h'
  implicit none             ! implicit? Just say no!
  include 'interface.h'
  include 'timing.h'
  !
  !     1996 Bernd Pfrommer
  !
  !     INPUT:
  !     -----
  !
  type(parallel_gspace), intent(in) :: gs            ! the gspace for the data
  type(fft_struc), intent(in) :: ffts                ! work arrays for the fft 
  integer, intent(in) :: nwfn            ! number of wavefunctions to convolve
  complex(dp), intent(in) :: &
       vloc(gs%r_size), &                   ! the local potential in realspace
       psi(gs%length * nwfn)                   ! the original wave function(s)
  !
  !     OUTPUT:
  !     ------
  !
  complex(dp), intent(out) :: &                            ! vpsi = vloc * psi
       vpsi(gs%length * nwfn)
  !
  !     DESCRIPTION:
  !     -----------
  !
  !     Applies the local potential vloc to a wave function psi 
  !     by 
  !            1) inverse FFT to realspace
  !            2) Multiply with vloc
  !            3) FFT to gspace
  !
  !
  !     ---------------------- local variables ----------------------
  !
  integer :: i, ifn
  real(dp) :: t0, ttot, t12i, t12f, tfc
  real(dp), external :: gimmetime

m4_ifdef([INTERFACE],[
  interface
     subroutine fourier_transform_12(idir, ffts, gs, gsdat, rspace, nfn)
       include 'use.h'
       integer :: idir, nfn
       type(fft_struc) :: ffts
       type(parallel_gspace) :: gs
       complex(dp), target :: rspace(gs%r_size * nfn)
       complex(dp) :: gsdat(gs%length * nfn)
     end subroutine fourier_transform_12
  end interface
])

  FFT_HEADER

  !
  !     now convolute with local potential
  !

m4_ifdef([FAST_CONVOLUTE],[
  !
  !     this is the faster convolute technique
  !
  TIMEGET(t0)
m4_ifdef([INTERFACE],[
  call fourier_transform_12(-1, ffts, gs, psi(1), ffts%rspacebuf, nwfn)
],[
  call fourier_transform_12(-1, ffts, gs, psi(1), ffts%rspacebuf(1), nwfn)
])
  m4_ifdef([TIMING],[
  TIMEDIFF(ttot, t0)
  t12i = ttot
  ttot = 1.0d2 / ttot
  write(9,123) tyfft, tzfft, tunfold, ttrods, &
       t0t1buf, t0rspace, tlt1, tlt2, tt1, tt2
  write(9,124) tyfft * ttot, tzfft * ttot, &
       tunfold * ttot, ttrods * ttot, t0t1buf * ttot, &
       t0rspace * ttot,  tlt1 * ttot, tlt2 * ttot, &
       tt1 * ttot, tt2 * ttot    
])
  TIMEGET(t0)
  do ifn = 0, nwfn - 1
m4_ifdef([INTERFACE],[
     call fast_convolute(ffts, gs, psi(ifn * gs%length + 1), &
          vpsi(ifn * gs%r_size + 1), &
          ffts%rspacebuf(ifn * gs%r_size + 1:(ifn + 1) * gs%r_size), &
          vloc)
],[
     call fast_convolute(ffts, gs, psi(ifn * gs%length + 1), &
          vpsi(ifn * gs%r_size + 1), &
          ffts%rspacebuf(ifn * gs%r_size + 1), vloc(1))
])
  end do
  TIMEDIFF(tfc, t0)

m4_ifdef([TIMING],[
  TIMEGET(t0)
  tunfold = dzero ; txfft = dzero ; tyfft = dzero ; tzfft = dzero
  t0rspace = dzero ; ttrods = dzero ; t0t1buf = dzero ; tlt1 = dzero
  tt1 = dzero ; tlt2 = dzero ; tt2 = dzero
])
m4_ifdef([INTERFACE],[
  call fourier_transform_12(1, ffts, gs,vpsi(1), ffts%rspacebuf, nwfn)
],[
  call fourier_transform_12(1, ffts, gs,vpsi(1), ffts%rspacebuf(1), nwfn)
])
  m4_ifdef([TIMING],[
  TIMEDIFF(ttot, t0)
  t12f = ttot
  ttot = 1.0d2 / ttot
  write(9,223) tyfft, tzfft, tunfold, ttrods, &
       t0t1buf, t0rspace, tlt1, tlt2, tt1, tt2
  write(9,224) tyfft * ttot, tzfft * ttot, &
       tunfold * ttot, ttrods * ttot, t0t1buf * ttot, &
       t0rspace * ttot,  tlt1 * ttot, tlt2 * ttot, &
       tt1 * ttot, tt2 * ttot
  ttot = 1.0d2 / (t12i + t12f + tfc)
  write(9,110) 1.0d2 / ttot, t12i * ttot, tfc * ttot, t12f * ttot
])
],[
  !
  !     for some architectures, standard technique is better
  !
  call fourier_transform(-1, ffts, gs, psi(1), ffts%rspacebuf(1), nwfn)
  FFT_CONVOL(ffts%r_size, ffts%rspacebuf, vloc, 1, nwfn)
  call fourier_transform(1, ffts, gs, vpsi(1), ffts%rspacebuf(1), nwfn)
])

100 format('TIME FOR ',a30,f12.6)
110 format('FFT:',f8.4,'   FFTI:',f8.1,'  CONV:',f8.1,'  FFTF:',f8.1)
123 format('FFTI:',2f8.4,', UFOLD:',f8.4,', TRODS:',f8.4, &
       ', ZBUF:', f8.4,', ZRSPC:', f8.4,', TLT1:', f8.4, &
       ', TLT2:', f8.4,', TC1:', f8.4,', TC2:', f8.4)
124 format('FFTI:',2f8.1,', UFOLD:',f8.1,', TRODS:',f8.1, &
       ', ZBUF:', f8.1,', ZRSPC:', f8.1,', TLT1:', f8.1, &
       ', TLT2:', f8.1,', TC1:', f8.1,', TC2:', f8.1)
223 format('FFTF:',2f8.4,', UFOLD:',f8.4,', TRODS:',f8.4, &
       ', ZBUF:', f8.4,', ZRSPC:', f8.4,', TLT1:', f8.4, &
       ', TLT2:', f8.4,', TC1:', f8.4,', TC2:', f8.4)
224 format('FFTF:',2f8.1,', UFOLD:',f8.1,', TRODS:',f8.1, &
       ', ZBUF:', f8.1,', ZRSPC:', f8.1,', TLT1:', f8.1, &
       ', TLT2:', f8.1,', TC1:', f8.1,', TC2:', f8.1)

end subroutine fft_convolute
